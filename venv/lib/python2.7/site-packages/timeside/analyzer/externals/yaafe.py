# -*- coding: utf-8 -*-
#
# Copyright (c) 2013 Thomas Fillon <thomas@parisson.com>

# This file is part of TimeSide.

# TimeSide is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.

# TimeSide is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with TimeSide.  If not, see <http://www.gnu.org/licenses/>.

# Author : Thomas Fillon <thomas@parisson.com>
"""
Module Yaafe Analyzer
"""

from timeside.core import implements, interfacedoc
from timeside.analyzer.core import Analyzer
from timeside.api import IAnalyzer

import yaafelib
import numpy as np
from scipy.signal import lfilter, butter
from timeside.analyzer.preprocessors import downmix_to_mono
from timeside.tools.parameters import HasTraits, ListUnicode, Float

PMF_FP = np.array([.122,.1708,.1464,.1098,.08723,.06466,.04819,.03965,
          .03294,.02684,.02257,.01891, .01525,.0122,.01037,.00915,
          .00793,.00671,.0061,.00549,.00488,.00427,.00427,.00366,
          .003355,.00305,.00244,.00183,.00183,.00183,.00122,.000613,
          .000552,.000122,.000186,.00043,.00043,.00043,.000186,.000186,
          .00104])
    
PMF_NS = np.array([.00366,.0183,.02196,.02623,.02806,.0305, .03172,.033245,
          .03355,.03294,.03355,.03294,.033245,.03416,.03294,.03294,
          .03233,.03172,.0305,.02928,.02806,.02745,.02623,.0244,
          .02318,.02257,.02135,.02013,.01891,.01769,.01586,.01464,
          .01403,.013115,.011895,.01098,.01098,.01037,.010065,.00976,
          .064565])

MAX_FMTS = 5
PREEMPH_COEF = .9375
FP_CONSEC_THRESH = 9
QUIET_CONSEC_THRESH = 4
LOG = '/home/mike/speaky/audio/loudforms.log'
FIXED_MSG = '\t---Much better---'

def pmf_fpause(stdev):
    bin_i = int(stdev) / 5
    if bin_i > 40:
        bin_i = 40

    return PMF_FP[bin_i]

def pmf_nspeech(stdev):
    bin_i = int(stdev) / 5
    if bin_i > 40:
        bin_i = 40

    return PMF_NS[bin_i]

def loglike(stdev):
    return np.log10(pmf_fpause(stdev)) - np.log10(pmf_nspeech(stdev))
loglike_arr = np.frompyfunc(loglike, 1, 1)

def preemph(data):
    return lfilter([1., -1*PREEMPH_COEF], 1, data)
# def preemph(arr):
#     return arr[1:] - PREEMPH_COEF * arr[:len(arr)-1]

def bandpass(data, samprate):
    nyq = .5 * samprate
    lowpass, hipass = 500/nyq, 5000/nyq # buttord gave me 500 low freq critical value
    numer, denom = butter(2, [500, 5000], btype='bandpass', analog=True)
    return lfilter(numer, denom, data)
    

class Yaafe(Analyzer):
    """Yaafe feature extraction library interface analyzer

    Parameters
    ----------
    feature_plan : list, optional
        Yaafe feature plan as a list of feature definition,
        default to ['mfcc: MFCC blockSize=512 stepSize=256']
    input_samplerate : int, optional
        The samplerate, default to 32000.

    Examples
    --------
    >>> import timeside
    >>> from timeside.tools.test_samples import samples
    >>> from timeside.core import get_processor
    >>> source = samples['C4_scale.wav']
    >>> FileDecoder = get_processor('file_decoder')
    >>> YaafeAnalyzer = get_processor('yaafe')
    >>> # feature extraction defition
p    >>> feature_plan = ['mfcc: MFCC CepsIgnoreFirstCoeff=0 blockSize=1024 stepSize=256',
    ...                 'mfccd1: MFCC CepsIgnoreFirstCoeff=0 blockSize=1024 stepSize=256 > Derivate DOrder=1',
    ...                 'mfccd2: MFCC CepsIgnoreFirstCoeff=0 blockSize=1024 stepSize=256 > Derivate DOrder=2',
    ...                 'zcr: ZCR blockSize=1024 stepSize=256']
    >>> decoder = FileDecoder(uri=source)
    >>> yaafe = YaafeAnalyzer(feature_plan=feature_plan,
    ...                       input_samplerate=16000)
    >>> pipe = (decoder | yaafe)
    >>> pipe.run()
    >>> print yaafe.results.keys()
    ['yaafe.mfccd1', 'yaafe.mfcc', 'yaafe.mfccd2', 'yaafe.zcr']
    >>> # Access to one of the result:
    >>> res_mfcc = yaafe.results['yaafe.mfcc']
    >>> print type(res_mfcc.data_object)
    <class 'timeside.analyzer.core.FrameValueObject'>
    >>> res_mfcc.data  # doctest: +ELLIPSIS
    array([[...]])
"""
    implements(IAnalyzer)

    # Define Parameters
    class _Param(HasTraits):

        feature_plan = ListUnicode
        input_samplerate = Float

########## CHANGES FOR LOGGING BELOW (including additional arg) ################
    def __init__(self, feature_plan=None, input_samplerate=32000, log=LOG):
        super(Yaafe, self).__init__()

        self.input_samplerate = input_samplerate
        # Check arguments
        if feature_plan is None:
            feature_plan = ['mfcc: MFCC blockSize=512 stepSize=256']

        self.feature_plan = feature_plan
        self.yaafe_engine = None
        ##HERE###
        self.log = log
        self.counter = 0
        self.outcounter = 0
        self.fp_count = 0
        self.quiet = 0

    @interfacedoc
    def setup(self, channels=None, samplerate=None,
              blocksize=None, totalframes=None):
        super(Yaafe, self).setup(channels, samplerate, blocksize, totalframes)

        # Setup Yaafe Feature plan and Dataflow
        yaafe_feature_plan = yaafelib.FeaturePlan(sample_rate=samplerate)
        for feat in self.feature_plan:
            yaafe_feature_plan.addFeature(feat)

        self.data_flow = yaafe_feature_plan.getDataFlow()

        # Configure a YAAFE engine
        self.yaafe_engine = yaafelib.Engine()
        self.yaafe_engine.load(self.data_flow)
        self.yaafe_engine.reset()
        
        self._LOUD_WINDOW = np.floor(2048.0 / self.yaafe_engine.getOutputs()['loud']['sampleStep'])
        self.louds = []
        self.rates = []
        #self.input_samplerate = samplerate
        #self.input_blocksize = blocksize
        #### LOGFILE OPENING #####
        self.log = open(self.log, 'w')
#        self.loud = None

    @property
    def force_samplerate(self):
        """Yaafe analyzer force the pipe samplerate to match
        the `input_samplerate` parameters
        """
        return self.input_samplerate

    @staticmethod
    @interfacedoc
    def id():
        return "yaafe"

    @staticmethod
    @interfacedoc
    def name():
        return "Yaafe Descriptor"

    @staticmethod
    @interfacedoc
    def unit():
        return ''

    def syll_rate_mean(self):
        return np.mean(self.rates)

    def syll_rate_std(self):
        return np.std(self.rates)

    def loud_mean(self):
        return np.mean(self.louds)

    def loud_std(self):
        return np.std(self.louds)

    def check_loudness(self, loud_frames):
        for i in np.arange(self._LOUD_WINDOW, loud_frames.shape[0] + 1, self._LOUD_WINDOW):
            loudwindow = loud_frames[i-self._LOUD_WINDOW:i]
            loudness = np.mean(loudwindow)
            if loudness > 3:
                self.louds.append(loudness)
            # engy_window = energy_frames[i-self._LOUD_WINDOW:i]
            # energy = np.mean(engy_window)
#            print 'loudval:\t%.1f' % loudness
#            loudness = (loudness + np.median(window)) / 2.0
            if loudness < 10 and self.quiet:
                print('\t^^^SPEAK UP!!^^^')
                if self.quiet < QUIET_CONSEC_THRESH:
                    self.quiet += 1 # increment quiet streak
            # elif energy < 8 and self.quiet:
            #     print('\t^^^SPEAK UP!! (energy)^^^')
            #     if self.quiet < QUIET_CONSEC_THRESH:
            #         self.quiet += 1 # increment quiet streak
            elif loudness < 5: # start new quiet streak
                self.quiet = 1
            elif self.quiet:
                self.quiet -= 1
                if not self.quiet:
                    print FIXED_MSG
                

    def extract_formants(self, lpc_frames):
        formants = np.zeros((len(lpc_frames), MAX_FMTS), dtype=np.float64)
        f0s = self.process_pipe.processors[1].pitches[-1 * len(lpc_frames):]
#        print 'pitchval:\t%.2f' % np.mean(f0s)
        frame_i = 0
        for lpcs in lpc_frames:
            self.outcounter += 1
            self.log.write('LPC frame %d:' % self.outcounter)
            # if np.all(np.isnan(lpcs)):
            #     continue
#            print lpcs
            lpcs = lpcs[np.isfinite(lpcs)]
            roots = np.roots(lpcs)
            roots = roots[np.imag(roots) >= 0]
            angles = np.angle(roots)
            raterads = self.input_samplerate / (2 * np.pi)
            freqs = angles * raterads
#            bws = -.5 * raterads * np.log(np.absolute(roots))

#            bws = bws[np.argsort(freqs)]
            freqs.sort()
            self.log.write('\t%.3f' % f0s[frame_i])
            for fi in np.arange(min(len(freqs), MAX_FMTS)):
#                freq, bw = freqs[fi], bws[fi]
                freq = freqs[fi]
                if freq > 90: #and bw < 400:
                    self.log.write('\t%.3f' % freq)
                    formants[frame_i, fi] = freq
            self.log.write('\n')
            frame_i += 1
        
        self.log.write('\n')
        return formants

    def find_fillers(self, formants, eod):
    #    formants = formants[np.all(formants[:, :2] > 0, axis=1)]
        aubio_pitch = self.process_pipe.processors[1]
        if eod:
            f0s = np.array(aubio_pitch.pitches[-1 * formants.shape[0]:])
        else:
            f0s = np.array(aubio_pitch.pitches[-1 * aubio_pitch.frames_per_buff:])
#        print '\nGot %d pitches but %d formants...' % (len(f0s), formants.shape[0])
        assert len(f0s) == formants.shape[0]
#        import pdb; pdb.set_trace()

        formants = np.concatenate((f0s.reshape(-1, 1), formants[:, :3]), axis=1)
        formants = formants[np.all(formants[:, 2:], axis=1) &
                            np.any(formants[:, :2], axis=1)]
        if float(formants.shape[0]) / len(f0s) < .4 or formants.shape[0] < 7:
#            print 'Too many frames lacking some f. Skipping buffer'
            return 0

#        import pdb; pdb.set_trace()
        formstds = np.empty((formants.shape[0] - 6, formants.shape[1]), dtype=formants.dtype)
        for i in np.arange(3, formants.shape[0] - 3):
            formstds[i-3, :] = np.std(formants[i-3:i+4, :], axis=0)
#            print 'f0/Formant stdevs:\t' + str(formstds[i-3, :])
        # f1s, f2s, f3s = formants[:, 0], formants[:, 1], formants[:, 2]
        # f1stds = [np.std(f1s[i-3:i+4]) for i in np.arange(3, len(f1s) - 3)]
        # f2stds = [np.std(f2s[i-3:i+4]) for i in np.arange(3, len(f2s) - 3)]
        # f3stds = [np.std(f3s[i-3:i+4]) for i in np.arange(3, len(f1s) - 3)]
    #    f1stds, f2stds = np.array(f1stds), np.array(f2stds)
#        f1stds, f2stds, f3stds = np.array(f1stds), np.array(f2stds), np.array(f3stds)
    #    f1fps, f2fps = loglike_arr(f1stds), loglike_arr(f2stds)
        loglikes = loglike_arr(formstds)
        fps = self._intersect_nCk(loglikes)
    #     f1fps, f2fps, f3fps = loglike_arr(f1stds), loglike_arr(f2stds), loglike_arr(f3stds)
    #     f1fps = (f1fps > .02)[0]
    #     f2fps = np.where(f2fps > 0)[0]
    #     f3fps = np.where(f3fps > 0)[0]
    # #    fps = np.intersect1d(f1fps, f2fps)
    #     fps = np.intersect1d(np.intersect1d(f1fps, f2fps), f3fps)
        self.log.write('%s\n' % str(fps))
        prev_fp_count = self.fp_count
        self._find_streaks(fps)

        return self.fp_count - prev_fp_count

    # find consecutive frames that surpass threshold
    def _find_streaks(self, indices):
        i = -1
        found = False
        while i < len(indices) - FP_CONSEC_THRESH:
            i += 1
            if found:
                if indices[i] - indices[i-1] > 15:
                    found = False
                else:
                    continue
                
            if np.array_equal(np.ediff1d(indices[i:i+FP_CONSEC_THRESH]), np.ones(FP_CONSEC_THRESH-1)):
                msg = 'Filled Pause!\n\tTry to focus on your enunciation to avoid more filler words.\n'
                print msg
                self.log.write(msg)
                found = True
                self.fp_count += 1
                i += FP_CONSEC_THRESH - 1

    # get common elements among any k-sized subset of n sets
    def _intersect_nCk(self, mx):
#        import pdb; pdb.set_trace()
        f0fps = np.where(mx[:, 0] > .25)[0]
        f1fps = np.where(mx[:, 1] > .25)[0]
        f2fps, f3fps = np.nonzero(mx[:, 2] > .25)[0], np.nonzero(mx[:, 3] > .25)[0]
        f0_f1_fps, f2_f3_fps = np.intersect1d(f0fps, f1fps), np.intersect1d(f2fps, f3fps)
        intersect_nck = np.union1d(np.intersect1d(f0_f1_fps, f2fps), np.intersect1d(f0_f1_fps, f3fps))
        intersect_nck = np.union1d(intersect_nck,
                         np.union1d(np.intersect1d(f0fps, f2_f3_fps), np.intersect1d(f1fps, f2_f3_fps)))
#        intersect_nck = np.union1d(intersect_nck, f2_f3_fps)
        return intersect_nck

    def get_rate(self, apeak_frames):
#        print apeak_frames
        sylls = 0
#        import pdb; pdb.set_trace()
        for frame in apeak_frames[:]:
            if frame[0] >= 8.0:
                sylls += np.log10(frame[0])
                if frame[2] >= 8.0:
                    sylls += np.log10(frame[2])
#        sylls = len(np.where(apeak_frames[:, 0] >= 8)[0]
#                    + len(np.where(apeak_frames[:, 2] >= 8)[0]))
        
        rate = sylls * 2.0 * (8000.0/8192)
        self.rates.append(rate)

        if len(self.rates) < 4:
            curr_rate = np.mean(self.rates)
        else:
            curr_rate = np.mean(self.rates[-4:])
            
        if curr_rate >= 6.0:
            print 'Woah, slow down!'
            print "You'repeaking at %.2f syll/sec. You want to be below 5." % curr_rate
        return curr_rate

    

    def process(self, frames, eod=False):
        # do self things...
        # Convert to float64and reshape
        # for compatibility with Yaafe engine
        self.counter += 1
        self.log.write('AUDIO FRAME %d\n' % self.counter)
        # Preprocessing steps for LPC (filled pauses) and Loudness analysis
#        win_frames = frames * np.hamming(len(frames))
#        win_frames = preemph(win_frames)
#        bp_frames = bandpass(frames)
        
#        yaafe_frames = frames.astype(np.float64).reshape(1, -1)
#        print len(frames), len(yaafe_frames), frames[3]
        # write audio array on 'audio' input
#        self.yaafe_engine.writeInput('audio', yaafe_frames)
        # process available data
#        self.yaafe_engine.process()
#        print self.yaafe_engine.getOutputs()
#        lpc_frames = self.yaafe_engine.readOutput('lpc')
#        print lpc_frames

        if True:#self.counter % 5 == 0:
            yaafe_frames = frames.astype(np.float64).reshape(1, -1)
            feats = self.yaafe_engine.processAudio(yaafe_frames)
            # if self.loud is None:
            #     self.loud = feats['loud']
            # else:
            #     self.loud = np.concatenate((self.loud, feats['loud']))
            lpc_frames, loud_frames = feats['lpc'], feats['loud']
            apeak_frames = feats['autopeaks']
#            import pdb; pdb.set_trace()
#            print 'Read %d lpc result frames' % len(lpc_frames)
            if np.any(lpc_frames):
                formants = self.extract_formants(lpc_frames)
                fpcount_in_buff = self.find_fillers(formants, eod)
            if np.any(loud_frames) and np.any(apeak_frames):
                self.check_loudness(loud_frames)
                syll_rate =  self.get_rate(apeak_frames)

#         if eod:
#             # flush yaafe engine to process remaining data
#             self.yaafe_engine.flush()
#             lpc_frames = self.yaafe_engine.readOutput('lpc')
# #            print lpc_frames
#             print 'Read %d lpc result frames at eod' % len(lpc_frames)
#             formants = self.extract_formants(lpc_frames)
#             self.find_fillers(formants)

        return frames, eod

    def post_process(self):
        ########### CLOSE LOG FILE ##############
        self.log.close()
#        lpc_frames = self.yaafe_engine.readOutput('lpc')
#        print lpc_frames
        # Get feature extraction results from yaafe
        print "Approximately %d filled pauses were detected" % self.fp_count
        featNames = self.yaafe_engine.getOutputs().keys()
        if len(featNames) == 0:
            raise KeyError('Yaafe engine did not return any feature')

#        print featNames
#        test_results = {} # reset dict for testing
        for featName in featNames:
            result = self.new_result(data_mode='value', time_mode='framewise')
            result.id_metadata.id += '.' + featName
            result.id_metadata.name += ' ' + featName
            # Read Yaafe Results
            result.data_object.value = self.yaafe_engine.readOutput(featName)

            yaafe_metadata = self.yaafe_engine.getOutputs()[featName]
            result.data_object.frame_metadata.blocksize = yaafe_metadata['frameLength']
            result.data_object.frame_metadata.stepsize = yaafe_metadata['sampleStep']
            result.data_object.frame_metadata.samplerate = yaafe_metadata['sampleRate']

            # Store results in Container
            if len(result.data_object.value):
                self.add_result(result)
#            test_results[result.id] = result


if __name__ == "__main__":
    import doctest
    import timeside
    doctest.testmod(timeside.analyzer.externals.yaafe, verbose=True)
