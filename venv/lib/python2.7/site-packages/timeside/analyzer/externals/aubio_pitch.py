# -*- coding: utf-8 -*-
#
# Copyright (c) 2013 Paul Brossier <piem@piem.org>

# This file is part of TimeSide.

# TimeSide is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.

# TimeSide is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with TimeSide.  If not, see <http://www.gnu.org/licenses/>.

# Author: Paul Brossier <piem@piem.org>
from __future__ import absolute_import

from timeside.core import implements, interfacedoc
from timeside.analyzer.core import Analyzer
from timeside.api import IAnalyzer
from timeside.analyzer.preprocessors import downmix_to_mono, frames_adapter
from aubio import pitch
import numpy as np
from timeside.analyzer.utils import nextpow2
#from timeside.analyzer.externals.yaafe import loglike_arr, FP_CONSEC_THRESH

from ...tools.parameters import Float, HasTraits


class AubioPitch(Analyzer):

    """Aubio Pitch estimation analyzer"""
    implements(IAnalyzer)  # TODO check if needed with inheritance

    # Define Parameters
    class _Param(HasTraits):
        blocksize_s = Float
        stepsize_s = Float

    def __init__(self, blocksize_s=None, stepsize_s=None):

        super(AubioPitch, self).__init__()

        self._blocksize_s = blocksize_s
        self._stepsize_s = stepsize_s

    @interfacedoc
    def setup(self, channels=None, samplerate=None,
              blocksize=None, totalframes=None):
        super(AubioPitch, self).setup(channels,
                                      samplerate,
                                      blocksize,
                                      totalframes)
        # Frame parameters setup
        if self._blocksize_s:
            self.input_blocksize = nextpow2(self._blocksize_s)
        else:
            self.input_blocksize = 2048

        if self._stepsize_s:
            self.input_stepsize = nextpow2(self._stepsize_s)
        else:
            self.input_stepsize = nextpow2(self.input_blocksize / 2)

        self.result_blocksize = self.input_blocksize
        self.result_stepsize = self.input_stepsize
        self._PITCH_WINDOW = int(4096.0 / self.input_blocksize)
        self._BUFF_FRAMES = (self.process_pipe.processors[0].output_blocksize \
                             - (self.input_blocksize // 2)) // self.input_stepsize + 2
        
        # Aubio Pitch set-up
        self.aubio_pitch = pitch(
            "default", self.input_blocksize, self.input_stepsize,
            samplerate)
        self.aubio_pitch.set_unit("freq") #Hz?
        self.block_read = 0
        self.pitches = []
#        self.pitch_confidences = []
        self.pitch_stds = []
        self.monotone = 0

    @staticmethod
    @interfacedoc
    def id():
        return "aubio_pitch"

    @staticmethod
    @interfacedoc
    def name():
        return "f0 (aubio)"

    @staticmethod
    @interfacedoc
    def unit():
        return "Hz"

    @property
    def frames_per_buff(self):
        return self._BUFF_FRAMES

    def __str__(self):
        return "pitch values"

    # process is run for EACH ADAPTED (i.e. 256 len) frame!
    @downmix_to_mono
    @frames_adapter
    def process(self, frames, eod=False):
        #time = self.block_read * self.input_stepsize * 1. / self.samplerate()
#        currpitches = [self.aubio_pitch(frames)[0]]

        currpitch = self.aubio_pitch(frames)[0]
#        print 'Measured %d pitches (f0):' % len(currpitches)
#        print self.aubio_pitch(frames)
        self.pitches.append(currpitch)
        self.block_read += 1
#        self.pitches += [self.aubio_pitch(frames)[0]]
#        self.pitch_confidences += [
#            np.nan_to_num(self.aubio_pitch.get_confidence())]
        # ADDED RESULTS FROM ME #
        if len(self.pitches) % self._PITCH_WINDOW == 0:
            window = np.array(self.pitches[-1 * self._PITCH_WINDOW:])
            window = window[(window > 50) & (window < 300)]
            if len(window) / float(self._PITCH_WINDOW) < .7:
                return frames, eod
#            f0stds = [np.std(window[i-3:i+4]) for i in np.arange(3, len(window) - 3)]

            std = np.std(window)
            self.pitch_stds.append(std)
            if std < 30 and self.monotone < 3:
                print "You're speaking in monotone. Liven yo speech - vary yo pitch!"
                self.monotone += 1 #set to to
            elif std < 30:
                self.monotone = 1 # set to 1
            elif self.monotone:
                self.monotone -= 1
                if not self.monotone:
                    print '\t---Much more charasimatic! Great job!---'
            
        return frames, eod

    def post_process(self):
        # parameters : None # TODO check with Piem "default" and "freq" in
        # setup
        valid_pitches = np.array(self.pitches)
        valid_pitches = valid_pitches[(valid_pitches > 50) & (valid_pitches < 300)]
        print 'There were %d total invalid f0s tossed' % (len(self.pitches) - len(valid_pitches))
        
        pitch = self.new_result(data_mode='value', time_mode='framewise')
        pitch.id_metadata.id += '.' + "pitch"
        pitch.id_metadata.name += ' ' + "pitch"
        pitch.id_metadata.unit = "Hz"
        pitch.data_object.value = valid_pitches.tolist()
        self.add_result(pitch)
        print '\nGlobal Pitch Stdev = %.2f' % np.std(valid_pitches)

        # pitch_confidence = self.new_result(
        #     data_mode='value', time_mode='framewise')
        # pitch_confidence.id_metadata.id += '.' + "pitch_confidence"
        # pitch_confidence.id_metadata.name += ' ' + "pitch confidence"
        # pitch_confidence.id_metadata.unit = None
        # pitch_confidence.data_object.value = self.pitch_confidences
        # self.add_result(pitch_confidence)

        pitch_std = self.new_result(data_mode='value', time_mode='framewise')
        pitch_std.id_metadata.id += '.pitch_std'
        pitch_std.id_metadata.name = 'pitch_std'
        pitch_std.data_object.value = self.pitch_stds
        self.add_result(pitch_std)
        print "Median 'framewise' Stdev = %.2f" % np.median(self.pitch_stds)
#        print "Mean 'buffer-wise' stdev: %.2f" % np.mean(self.pitch_stds)

        pitch_range = self.new_result(data_mode='value', time_mode='global')
        pitch_range.id_metadata.id += '.pitch_range'
        pitch_range.id_metadata.name = 'pitch_range'
        pitch_range.data_object.value = max(pitch.data) - min(pitch.data)
        self.add_result(pitch_range)
        print 'Global pitch range (max - min) = %.2f' % pitch_range.data_object.value
#        print 'Number of pitch vals computed: %d' % len(self.pitches)
